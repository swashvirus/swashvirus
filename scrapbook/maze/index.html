<html>

<head>
    <title>Maze Machine</title>
    <script src="./jquery.js"></script>
    <style type="text/css">
        #maze {
            border-collapse: collapse;
        }

        #maze td {
            width: 20px;
            height: 20px;
        }
    </style>
</head>

<body>

    <table id="maze">
        <!--<canvas id="canvas">
        </canvas>-->
        <tbody>
            <!-- space reserved for maze body -->
        </tbody>
    </table>

    <script>
        "use strict";
        let maze = function(x, y) {
            // Establish variables and starting grid
            var totalCells = x * y;
            var cells = new Array();
            var unvis = new Array();
            for (var i = 0; i < y; i++) {
                cells[i] = new Array();
                unvis[i] = new Array();
                for (var j = 0; j < x; j++) {
                    cells[i][j] = [0, 0, 0, 0];
                    unvis[i][j] = true;
                }
            }

            // Set a random position to start from
            var currentCell = [Math.floor(Math.random() * y), Math.floor(Math.random() * x)];
            var path = [currentCell];
            unvis[currentCell[0]][currentCell[1]] = false;
            var visited = 1;

            // Loop through all available cell positions
            while (visited < totalCells) {
                // Determine neighboring cells
                var pot = [
                    [currentCell[0] - 1, currentCell[1], 0, 2],
                    [currentCell[0], currentCell[1] + 1, 1, 3],
                    [currentCell[0] + 1, currentCell[1], 2, 0],
                    [currentCell[0], currentCell[1] - 1, 3, 1]
                ];
                var neighbors = new Array();

                // Determine if each neighboring cell is in game grid, and whether it has already been checked
                for (var l = 0; l < 4; l++) {
                    if (pot[l][0] > -1 && pot[l][0] < y && pot[l][1] > -1 && pot[l][1] < x && unvis[pot[l][0]][pot[l][1]]) {
                        neighbors.push(pot[l]);
                    }
                }

                // If at least one active neighboring cell has been found
                if (neighbors.length) {
                    // Choose one of the neighbors at random
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];

                    // Remove the wall between the current cell and the chosen neighboring cell
                    cells[currentCell[0]][currentCell[1]][next[2]] = 1;
                    cells[next[0]][next[1]][next[3]] = 1;

                    // Mark the neighbor as visited, and set it as the current cell
                    unvis[next[0]][next[1]] = false;
                    visited++;
                    currentCell = [next[0], next[1]];
                    path.push(currentCell);
                }
                // Otherwise go back up a step and keep going
                else {
                    currentCell = path.pop();
                }
            }
            return cells;
        }

        let solve = function(params) {
            let start = params.start;
            let end = params.end;
            let maze = params.maze;
            let memory = []
            let history = []
            history['count'] = 0;

            memory.push(start)
            while (memory.length > 0) {
                let i = memory.shift()
                if ((i[0] == end[0]) && (i[1] == end[1])) {
                    $('#' + end[0] + '-' + end[1]).css('background', 'red');
                    $('#' + start[0] + '-' + start[1]).css('background', 'blue');

                    break;
                }

                if (history[i[0] + '-' + i[1]] == true) continue;
                history[i[0] + '-' + i[1]] = true
                history['count']++

                let row = i[0];
                let col = i[1];

                if (row >= 0 && col >= 0 && row < maze.length && col < maze[0].length) {
                    let cell = maze[i[0]][i[1]]

                    setInterval(() => {
                        $('#' + i[0] + '-' + i[1]).css('background', 'lime');
                    }, 100 * history.count)

                    // [top, right, left, bottom]

                    if ((cell[0] == 1)) {
                        console.log('top')
                        memory.push([i[0] - 1, i[1]])
                    }

                    if ((cell[1] == 1)) {
                        console.log('right')
                        memory.push([i[0], i[1] + 1])
                    }

                    if ((cell[2] == 1)) {
                        console.log('bottom')
                        memory.push([i[0] + 1, (i[1])])
                    }

                    if ((cell[3] == 1)) {
                        console.log('left')
                        memory.push([i[0], i[1] - 1])
                    }
                }
            }
        }

        let render = function(mymaze) {
            // console.log(JSON.stringify(mymaze))
            for (var i = 0; i < mymaze.length; i++) {
                $('#maze > tbody').append("<tr>");
                for (var j = 0; j < mymaze[i].length; j++) {
                    var selector = i + "-" + j;
                    $('#maze > tbody').append("<td id='" + selector + "'>&nbsp;</td>");
                    if (mymaze[i][j][0] == 0) {
                        $('#' + selector).css('border-top', '2px solid black');
                    }
                    if (mymaze[i][j][1] == 0) {
                        $('#' + selector).css('border-right', '2px solid black');
                    }
                    if (mymaze[i][j][2] == 0) {
                        $('#' + selector).css('border-bottom', '2px solid black');
                    }
                    if (mymaze[i][j][3] == 0) {
                        $('#' + selector).css('border-left', '2px solid black');
                    }
                }
                $('#maze > tbody').append("</tr>");
            }

            /* let cnv = document.getElementById("canvas")
            let ctx = cnv.getContext("2d");
            
            let  WIDTH  = window.innerWidth,
            	 HEIGHT = window.innerHieght;
            
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            let numRows = maze.length;
            let numCols = maze[0].length;
            let cellWidth = WIDTH/numCols;
            let cellHeight = HEIGHT/numRows;
            let cellLength = cellWidth > cellHeight ? cellHeight : cellWidth;
            for (let row = 0; row < numRows; row++){
            	for (let col = 0; col < numCols; col++){
            		let cell = maze[row][col];
            		ctx.fillStyle = '#eee'
            		let rectX = col * cellLength;
            		let rectY = row * cellLength;
            		ctx.fillRect(rectX, rectY, cellLength, cellLength);
            	}
            } */
        };

        var mymaze = new maze(10, 10);
        render(mymaze)

        solve({
            start: [0, 0],
            end: [Math.round((Math.random() * mymaze.length - 1)), Math.round((Math.random() * mymaze[0].length - 1))],
            maze: mymaze
        })
    </script>
    <div>a maze solving algorithm</div>
    <div>refresh page to generate a new maze</div>
    </body>
</body>

</html>