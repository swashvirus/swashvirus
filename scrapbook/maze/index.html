<html>

<head>
    <title>Maze Machine</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="theme-color" content="#333" />
    <script src="./craters.js"></script>
    <script src="./jquery.js"></script>
	<style type="text/css">
	    body {
	        background: #fff;
	    }
	
	    #container {
	        width: 100%;
	        height: 100%;
	        margin: 0 auto;
	        padding: 0;
	    }
	
	    #gameViewport {
	        -webkit-transform: translate3d(0, 0, 0);
	        transform: translate3d(0, 0, 0)
	    }
	
	    html,
	    body,
	    canvas {
	        position: absolute;
	        left: 0;
	        top: 0;
	        margin: auto;
	        overscroll-behavior: contain
	    }
	</style>
</head>

<body>
    <div class="maze"></div>
    <script>
        "use strict";
        let maze = function(x, y) {
            // Establish variables and starting grid
            var totalCells = x * y;
            var cells = new Array();
            var unvis = new Array();
            for (var i = 0; i < y; i++) {
                cells[i] = new Array();
                unvis[i] = new Array();
                for (var j = 0; j < x; j++) {
                    cells[i][j] = [0, 0, 0, 0];
                    unvis[i][j] = true;
                }
            }

            // Set a random position to start from
            var currentCell = [Math.floor(Math.random() * y), Math.floor(Math.random() * x)];
            var path = [currentCell];
            unvis[currentCell[0]][currentCell[1]] = false;
            var visited = 1;

            // Loop through all available cell positions
            while (visited < totalCells) {
                // Determine neighboring cells
                var pot = [
                    [currentCell[0] - 1, currentCell[1], 0, 2],
                    [currentCell[0], currentCell[1] + 1, 1, 3],
                    [currentCell[0] + 1, currentCell[1], 2, 0],
                    [currentCell[0], currentCell[1] - 1, 3, 1]
                ];
                var neighbors = new Array();

                // Determine if each neighboring cell is in game grid, and whether it has already been checked
                for (var l = 0; l < 4; l++) {
                    if (pot[l][0] > -1 && pot[l][0] < y && pot[l][1] > -1 && pot[l][1] < x && unvis[pot[l][0]][pot[l][1]]) {
                        neighbors.push(pot[l]);
                    }
                }

                // If at least one active neighboring cell has been found
                if (neighbors.length) {
                    // Choose one of the neighbors at random
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];

                    // Remove the wall between the current cell and the chosen neighboring cell
                    cells[currentCell[0]][currentCell[1]][next[2]] = 1;
                    cells[next[0]][next[1]][next[3]] = 1;

                    // Mark the neighbor as visited, and set it as the current cell
                    unvis[next[0]][next[1]] = false;
                    visited++;
                    currentCell = [next[0], next[1]];
                    path.push(currentCell);
                }
                // Otherwise go back up a step and keep going
                else {
                    currentCell = path.pop();
                }
            }
            return cells;
        }

        let solve = function(params) {
            let start = params.start;
            let end = params.end;
            let maze = params.maze;
            let memory = []
            let history = []
            history['count'] = 0;

            memory.push(start)
            while (memory.length > 0) {
                let i = memory.shift()
                if ((i[0] == end[0]) && (i[1] == end[1])) {
                    maze[start[0]][start[1]]['color'] = 'blue'
                    maze[end[0]][end[1]]['color'] = 'red'
                    break;
                }

                if (history[i[0] + '-' + i[1]] == true) continue;
                history[i[0] + '-' + i[1]] = true
                history['count']++
                setTimeout(()=>{
                maze[i[0]][i[1]]['color'] = "lime";
				render(maze)}, 200 * history['count'])
				
                let row = i[0];
                let col = i[1];

                if (row >= 0 && col >= 0 && row < maze.length && col < maze[0].length) {
                    let cell = maze[i[0]][i[1]]
					// [top, right, left, bottom]

                    if ((cell[0] == 1)) {
                        // console.log('top')
                        memory.push([i[0] - 1, i[1]])
                    }

                    if ((cell[1] == 1)) {
                        // console.log('right')
                        memory.push([i[0], i[1] + 1])
                    }

                    if ((cell[2] == 1)) {
                        // console.log('bottom')
                        memory.push([i[0] + 1, (i[1])])
                    }

                    if ((cell[3] == 1)) {
                        // console.log('left')
                        memory.push([i[0], i[1] - 1])
                    }
                }
            }
        }

        let render = function(maze) {
			let  WIDTH  = window.innerWidth,
				 HEIGHT = window.innerHeight;
			
            window['cnv'] = (typeof window['cnv'] == 'undefined') ? new Craters.Canvas(WIDTH, HEIGHT, '.maze') : window['cnv'];
            let ctx = cnv.getContext("2d");
            
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            let numRows = maze.length;
            let numCols = maze[0].length;
            let cellWidth = WIDTH/numCols;
            let cellHeight = HEIGHT/numRows;
            let cellLength = cellWidth > cellHeight ? cellHeight : cellWidth;
            for (let row = 0; row < numRows; row++){
            	for (let col = 0; col < numCols; col++){
            		let cell = maze[row][col];
            		ctx.fillStyle = '#fff'
            		let rectX = col * cellLength;
            		let rectY = row * cellLength;
            		
            		ctx.beginPath();
            		if (cell[0] == 0) {
		        		// top right bottom left
		        		ctx.moveTo(rectX, rectY);
		        		ctx.lineTo(rectX + cellWidth, rectY);
            		}
            		if (cell[1] == 0) {
	            		ctx.moveTo(rectX + cellWidth, rectY);
	            		ctx.lineTo(rectX + cellWidth, rectY + cellLength);
            		}
		            if (cell[2] == 0) {
			            ctx.moveTo(rectX, rectY + cellLength);
			            ctx.lineTo(rectX + cellWidth, rectY + cellLength);
		            }
		            if (cell[3] == 0) {
			            ctx.moveTo(rectX, rectY);
			            ctx.lineTo(rectX, rectY + cellLength);
		            } 
					ctx.fillStyle = cell['color'] || '#fff';
    				ctx.lineWidth = 3;
    				ctx.stroke();
            		ctx.fillRect(rectX, rectY, cellLength, cellLength);
            	}
            }
        };

        var mymaze = new maze(14, 14)
	        solve({
	            start: [0, 0],
	            end: [Math.round(((Math.random() * (mymaze.length - 2)) + 1)), Math.round((Math.random() * mymaze[0].length - 1))],
	            maze: mymaze
            })
            
	        // render(mymaze)
    </script>
    </body>
</body>

</html>